## taskctx

目标：将协程作为 OS 中的 first-class 提供给内核开发者和应用程序开发者。

这里的协程特指 Rust 协程，因为 Rust 语言本身的特性，以及它对协程的支持，并且社区在推进 Rust for Linux 项目。

### 上下文分类

1. 协程上下文
2. 线程上下文
3. 中断上下文：中断处理程序借用了应用程序的内核栈。
4. 系统调用上下文切换
5. 进程上下文

由于中断上下文不属于任何进程，它与current没有任何关系（尽管此时current指向被中断的进程），所以中断上下文一旦睡眠或者放弃CPU，将无法被唤醒。所以也叫原子上下文（atomic context）。

为了保护中断句柄临界区资源，不能使用mutexes。如果获得不到信号量，代码就会睡眠，会产生和上面相同的情况，如果必须使用锁，则使用spinlock。

中断处理应该尽可能快，因为内核要响应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。在中断处理例程中执行耗时任务时，应该交由中断处理例程底半部来处理。

因为中断上下文是和特定进程无关的，它是内核代表硬件运行在内核空间，所以在中断上下文无法访问用户空间的虚拟地址

因为中断发生时，preempt和irq都被disable，直到中断返回。所以中断上下文和进程上下文不一样，中断处理例程的不同实例，是不允许在SMP上并发运行的。

如果想禁止这种中断，可以将中断处理例程定义成快速处理例程，相当于告诉CPU，该例程运行时，禁止本地CPU上所有中断请求。这直接导致的结果是，由于其他中断被延迟响应，系统性能下降。


### Unikernel

Unikernel 环境下，任务为协程，除了使用协程 await 让出外，还可能存在中断、使用同步的接口。当中断抢占或使用同步的接口进行任务切换时，任务将不再是协程的形式出现，而是以线程的方式。

1. 中断：中断处理程序直接借用了任务当前正在运行的栈，不属于任何一个任务
2. 同步让权：将协程以线程的形式保存，需要注意保存过程中发生中断抢占，上下文嵌套的问题

在中断的过程中，不可能发生主动让权的情况，因此需要注意的是在使用同步接口让权时，发生中断的情况，这时需要将其设置为不允许抢占的情况

### monolithic

宏内核环境下，在用户态的执行只能是以线程的形式存在，需要将上下文保存起来。

它在执行系统调用时，需要将上下文保存起来。在处理系统调用的过程中，会发生时钟中断，这种情况该怎么处理。也许不考虑与 starry 的兼容，一旦 trap 进入内核就开始切换到系统调用的协程，这样避免了上下文嵌套的问题。

在执行系统调用协程时，发生了时钟中断，则会将系统调用协程以线程的形式保存起来。

